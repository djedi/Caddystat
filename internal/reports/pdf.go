package reports

import (
	"bytes"
	"fmt"
	"time"

	"github.com/dustin/Caddystat/internal/storage"
)

// GeneratePDF generates a PDF report from the report data.
// This uses a simple PDF generation approach without external dependencies.
func GeneratePDF(data *ReportData) ([]byte, error) {
	pdf := newPDFWriter()

	// Title
	title := fmt.Sprintf("Caddystat %s Report", capitalizeFirst(data.ReportType))
	if data.Host != "" {
		title = fmt.Sprintf("%s - %s", title, data.Host)
	}
	pdf.addTitle(title)

	// Period
	pdf.addText(fmt.Sprintf("Period: %s to %s",
		data.PeriodStart.Format("January 2, 2006 15:04"),
		data.PeriodEnd.Format("January 2, 2006 15:04")))
	pdf.addText(fmt.Sprintf("Generated: %s", time.Now().Format("January 2, 2006 15:04 MST")))
	pdf.addLine()

	// Summary section
	pdf.addHeading("Summary")
	pdf.addText(fmt.Sprintf("Total Requests: %d", data.Summary.TotalRequests))
	pdf.addText(fmt.Sprintf("Unique Visitors: %d", data.Summary.UniqueVisitors))
	pdf.addText(fmt.Sprintf("Total Visits: %d", data.Summary.TotalVisits))
	pdf.addText(fmt.Sprintf("Page Views: %d", data.Summary.PageViews))
	pdf.addText(fmt.Sprintf("Bandwidth: %s", data.Summary.BandwidthHuman))
	pdf.addText(fmt.Sprintf("Avg Response Time: %.2f ms", data.Summary.AvgResponseTime))
	if data.Summary.BounceRate > 0 {
		pdf.addText(fmt.Sprintf("Bounce Rate: %.1f%%", data.Summary.BounceRate))
	}
	if data.Summary.AvgSessionLength > 0 {
		pdf.addText(fmt.Sprintf("Avg Session Length: %.0f seconds", data.Summary.AvgSessionLength))
	}
	pdf.addLine()

	// Status codes
	pdf.addHeading("Response Status Codes")
	pdf.addText(fmt.Sprintf("2xx (Success): %d", data.Summary.Status2xx))
	pdf.addText(fmt.Sprintf("3xx (Redirect): %d", data.Summary.Status3xx))
	pdf.addText(fmt.Sprintf("4xx (Client Error): %d", data.Summary.Status4xx))
	pdf.addText(fmt.Sprintf("5xx (Server Error): %d", data.Summary.Status5xx))
	pdf.addText(fmt.Sprintf("Error Rate: %.2f%%", data.Summary.ErrorRate))
	pdf.addLine()

	// Top Pages
	if len(data.TopPages) > 0 {
		pdf.addHeading("Top Pages")
		for i, p := range data.TopPages {
			if i >= 10 {
				break
			}
			pdf.addText(fmt.Sprintf("%d. %s (%d requests)", i+1, truncate(p.Path, 50), p.Count))
		}
		pdf.addLine()
	}

	// Top Referrers
	if len(data.TopReferrers) > 0 {
		pdf.addHeading("Top Referrers")
		for i, r := range data.TopReferrers {
			if i >= 10 {
				break
			}
			pdf.addText(fmt.Sprintf("%d. %s (%d hits)", i+1, truncate(r.Referrer, 50), r.Hits))
		}
		pdf.addLine()
	}

	// Browsers
	if len(data.Browsers) > 0 {
		pdf.addHeading("Browsers")
		for i, b := range data.Browsers {
			if i >= 5 {
				break
			}
			pdf.addText(fmt.Sprintf("%s: %.1f%% (%d hits)", b.Browser, b.Percent, b.Hits))
		}
		pdf.addLine()
	}

	// Operating Systems
	if len(data.OperatingSystems) > 0 {
		pdf.addHeading("Operating Systems")
		for i, o := range data.OperatingSystems {
			if i >= 5 {
				break
			}
			pdf.addText(fmt.Sprintf("%s: %.1f%% (%d hits)", o.OS, o.Percent, o.Hits))
		}
		pdf.addLine()
	}

	// Geographic breakdown (top countries)
	if len(data.Countries) > 0 {
		pdf.addHeading("Top Countries")
		countries := aggregateByCountry(data.Countries)
		for i, c := range countries {
			if i >= 10 {
				break
			}
			pdf.addText(fmt.Sprintf("%d. %s: %d requests", i+1, c.country, c.count))
		}
		pdf.addLine()
	}

	// Bot Statistics
	if data.Bots.TotalHits > 0 {
		pdf.addHeading("Bot Traffic")
		pdf.addText(fmt.Sprintf("Total Bot Hits: %d", data.Bots.TotalHits))
		pdf.addText(fmt.Sprintf("Bot Bandwidth: %s", formatBytes(data.Bots.BandwidthBytes)))
		if len(data.Bots.ByIntent) > 0 {
			pdf.addText("By Intent:")
			for intent, stats := range data.Bots.ByIntent {
				pdf.addText(fmt.Sprintf("  - %s: %d hits", intent, stats.Hits))
			}
		}
		pdf.addLine()
	}

	// Error Pages
	if len(data.ErrorPages) > 0 {
		pdf.addHeading("Top Error Pages")
		for i, e := range data.ErrorPages {
			if i >= 10 {
				break
			}
			pdf.addText(fmt.Sprintf("%d. %s (HTTP %d) - %d times", i+1, truncate(e.Path, 40), e.Status, e.Count))
		}
		pdf.addLine()
	}

	// Performance (if available)
	if data.Performance != nil {
		pdf.addHeading("Performance Statistics")
		pdf.addText(fmt.Sprintf("Min Response Time: %.2f ms", data.Performance.ResponseTime.Min))
		pdf.addText(fmt.Sprintf("Avg Response Time: %.2f ms", data.Performance.ResponseTime.Avg))
		pdf.addText(fmt.Sprintf("Max Response Time: %.2f ms", data.Performance.ResponseTime.Max))
		pdf.addText(fmt.Sprintf("P50: %.2f ms", data.Performance.ResponseTime.P50))
		pdf.addText(fmt.Sprintf("P95: %.2f ms", data.Performance.ResponseTime.P95))
		pdf.addText(fmt.Sprintf("P99: %.2f ms", data.Performance.ResponseTime.P99))
	}

	// Footer
	pdf.addLine()
	pdf.addText("Generated by Caddystat - https://github.com/dustin/Caddystat")

	return pdf.render()
}

// pdfWriter is a simple PDF generator.
type pdfWriter struct {
	objects    []pdfObject
	content    bytes.Buffer
	yPos       float64
	pageHeight float64
	pageWidth  float64
	margin     float64
	fontSize   float64
}

type pdfObject struct {
	data []byte
}

func newPDFWriter() *pdfWriter {
	return &pdfWriter{
		pageHeight: 842, // A4 height in points
		pageWidth:  595, // A4 width in points
		margin:     50,
		fontSize:   11,
		yPos:       792, // Start near top
	}
}

func (p *pdfWriter) addTitle(text string) {
	p.content.WriteString(fmt.Sprintf("BT /F1 18 Tf %f %f Td (%s) Tj ET\n",
		p.margin, p.yPos, escapePDFString(text)))
	p.yPos -= 30
}

func (p *pdfWriter) addHeading(text string) {
	if p.yPos < 100 {
		p.newPage()
	}
	p.yPos -= 10
	p.content.WriteString(fmt.Sprintf("BT /F1 14 Tf %f %f Td (%s) Tj ET\n",
		p.margin, p.yPos, escapePDFString(text)))
	p.yPos -= 20
}

func (p *pdfWriter) addText(text string) {
	if p.yPos < 50 {
		p.newPage()
	}
	p.content.WriteString(fmt.Sprintf("BT /F1 %f Tf %f %f Td (%s) Tj ET\n",
		p.fontSize, p.margin, p.yPos, escapePDFString(text)))
	p.yPos -= 15
}

func (p *pdfWriter) addLine() {
	p.yPos -= 10
}

func (p *pdfWriter) newPage() {
	p.yPos = 792
}

func (p *pdfWriter) render() ([]byte, error) {
	var buf bytes.Buffer

	// PDF header
	buf.WriteString("%PDF-1.4\n")

	// Object 1: Catalog
	obj1Offset := buf.Len()
	buf.WriteString("1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n")

	// Object 2: Pages
	obj2Offset := buf.Len()
	buf.WriteString("2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj\n")

	// Object 3: Page
	obj3Offset := buf.Len()
	buf.WriteString(fmt.Sprintf("3 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 %f %f] /Contents 4 0 R /Resources << /Font << /F1 5 0 R >> >> >>\nendobj\n",
		p.pageWidth, p.pageHeight))

	// Object 4: Content stream
	obj4Offset := buf.Len()
	contentData := p.content.Bytes()
	buf.WriteString(fmt.Sprintf("4 0 obj\n<< /Length %d >>\nstream\n", len(contentData)))
	buf.Write(contentData)
	buf.WriteString("\nendstream\nendobj\n")

	// Object 5: Font
	obj5Offset := buf.Len()
	buf.WriteString("5 0 obj\n<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>\nendobj\n")

	// Cross-reference table
	xrefOffset := buf.Len()
	buf.WriteString("xref\n")
	buf.WriteString("0 6\n")
	buf.WriteString("0000000000 65535 f \n")
	buf.WriteString(fmt.Sprintf("%010d 00000 n \n", obj1Offset))
	buf.WriteString(fmt.Sprintf("%010d 00000 n \n", obj2Offset))
	buf.WriteString(fmt.Sprintf("%010d 00000 n \n", obj3Offset))
	buf.WriteString(fmt.Sprintf("%010d 00000 n \n", obj4Offset))
	buf.WriteString(fmt.Sprintf("%010d 00000 n \n", obj5Offset))

	// Trailer
	buf.WriteString(fmt.Sprintf("trailer\n<< /Size 6 /Root 1 0 R >>\nstartxref\n%d\n%%%%EOF\n", xrefOffset))

	return buf.Bytes(), nil
}

func escapePDFString(s string) string {
	var result bytes.Buffer
	for _, c := range s {
		switch c {
		case '(':
			result.WriteString("\\(")
		case ')':
			result.WriteString("\\)")
		case '\\':
			result.WriteString("\\\\")
		default:
			if c > 127 {
				// Skip non-ASCII for basic PDF
				result.WriteRune('?')
			} else {
				result.WriteRune(c)
			}
		}
	}
	return result.String()
}

func truncate(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen-3] + "..."
}

type countryCount struct {
	country string
	count   int64
}

func aggregateByCountry(geos []storage.GeoStat) []countryCount {
	counts := make(map[string]int64)
	for _, g := range geos {
		country := g.Country
		if country == "" {
			country = "Unknown"
		}
		counts[country] += g.Count
	}

	result := make([]countryCount, 0, len(counts))
	for country, count := range counts {
		result = append(result, countryCount{country, count})
	}

	// Sort by count descending
	for i := 0; i < len(result)-1; i++ {
		for j := i + 1; j < len(result); j++ {
			if result[j].count > result[i].count {
				result[i], result[j] = result[j], result[i]
			}
		}
	}

	return result
}

